#include <stdio.h>
#include <stdlib.h>

//定义链表节点的结构体
typedef struct list_item{
        int data;                //存储的数据
        struct list_item *next;  //指向下一个节点的指针
}list_item;

//非递归方式释放链表空间的函数
void erase_list(list_item *head){
        list_item *current=head;  //当前节点指针
        list_item *next_node=NULL; //用于临时存储下一个节点的指针

        //遍历链表直到当前节点为NULL
        while(current!=NULL){
                next_node=current->next; //保存下一个节点的地址
                free(current);             //释放当前节点的内存
                current=next_node;       //移动到下一个节点
        }
}

//用于创建新节点的辅助函数
list_item* create_node(int data){
        list_item *new_node=(list_item *)malloc(sizeof(list_item));
        if(new_node!=NULL){
                new_node->data=data;
                new_node->next=NULL;
        }
        return new_node;
}

//用于创建新节点的辅助函数
list_item* create_node(int data){
        list_item *new_node=(list_item *)malloc(sizeof(list_item));
        if(new_node!=NULL){
                new_node->data=data;
                new_node->next=NULL;
        }
        return new_node;
}

//主函数，用于测试
int main(){
        //创建链表 1->2->3->NULL
        list_item *head=create_node(1);
        head->next=create_node(2);
        head->next->next=create_node(3);

        //释放链表空间
        erase_list(head);

        //打印链表，验证是否释放成功
        //注意：这里只是为了演示，实际释放后不应该再访问链表
        //list_item *current = head;
        //while (current != NULL) {
        //printf("%d ", current->data);
        //current = current->next;
        //}
        //printf("\n");

        return 0;
}
